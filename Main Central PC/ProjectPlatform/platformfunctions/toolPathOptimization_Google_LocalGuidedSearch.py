# -*- coding: utf-8 -*-
"""TSP_Drill_optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MwWkiD3LKMsI7Q7wMlOleRdGkGQ6zt1E
"""

!pip install ortools

import math
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp

def hole_data_details(file_name,tool_R=2.5, base_plane='xz'):
      file = open(file_name, "r")
      hole_centre_coord_data=[]
      cartesian_point_data=[]
      cartesian_point_data_x=[]
      cartesian_point_data_y=[]
      cartesian_point_data_z=[]
      data=[]
      for line in file:
        
        if(line[0]=='#'):
            data.append(line[0:-2])
            #
            #print(data)
            #
            if 'CYLINDRICAL_SURFACE' in line:
                data_array=data[-1].split(',')
                R_array=(data_array[2][:-1]).split('E')
                R=float(R_array[0])*10**(float(R_array[1]))
                if R==tool_R:
                    coord_array=data[-5].split(',')
                    #print(coord_array)
                    x_array=(coord_array[1][1:]).split('E')
                    y_array=(coord_array[2]).split('E')
                    z_array=(coord_array[3][:-2]).split('E')
                    #####
                    #####
                    ## Since distance matrix take integer values so here 
                    ## we multiply by 1000 to take care of decimal no.
                    ## while saving the coordinates We will divide it.
                    #####
                    #####
                    x=int((float(x_array[0])*10**(float(x_array[1])))*1000)
                    y=int((float(y_array[0])*10**(float(y_array[1])))*1000)
                    z=int((float(z_array[0])*10**(float(z_array[1])))*1000)
                    if base_plane == 'xy':
                      hole_centre_coord_data.append([x,y])
                    elif base_plane == 'yz':
                      hole_centre_coord_data.append([y,z])
                    else:
                      hole_centre_coord_data.append([x,z])
            elif 'CARTESIAN_POINT' in line:
                coord_array=data[-1].split(',')
                x_array=(coord_array[1][1:]).split('E')
                y_array=(coord_array[2]).split('E')
                z_array=(coord_array[3][:-2]).split('E')
                x=int((float(x_array[0])*10**(float(x_array[1])))*1000)
                y=int((float(y_array[0])*10**(float(y_array[1])))*1000)
                z=int((float(z_array[0])*10**(float(z_array[1])))*1000)
                if base_plane == 'xy':
                  cartesian_point_data.append([x,y])
                elif base_plane == 'yz':
                  cartesian_point_data.append([y,z])
                else:
                  cartesian_point_data.append([x,z])
                cartesian_point_data_x.append(x)
                cartesian_point_data_y.append(y)
                cartesian_point_data_z.append(z)
                
      hole_centre_coord_data=list(set(tuple(row) for row in hole_centre_coord_data))
      for i in range (len(hole_centre_coord_data)): hole_centre_coord_data[i]=list(hole_centre_coord_data[i])
      #print(hole_centre_coord_data)
      job_max_x=max(cartesian_point_data_x)
      job_max_y=max(cartesian_point_data_y)
      job_max_z=max(cartesian_point_data_z)
      job_min_x=min(cartesian_point_data_x)
      job_min_y=min(cartesian_point_data_y)
      job_min_z=min(cartesian_point_data_z)
      if base_plane == 'xy':
          thickness=job_max_z-job_min_z
      elif base_plane == 'yz' :
          thickness=job_max_x-job_min_x
      else:
          thickness=job_max_y-job_min_y


      machine_home_position=[job_min_x,job_min_y,job_min_z]

      for i in range (len(hole_centre_coord_data)):
          if base_plane == 'xy':

            hole_centre_coord_data[i][0]=hole_centre_coord_data[i][0]-machine_home_position[0]
            hole_centre_coord_data[i][1]=hole_centre_coord_data[i][1]-machine_home_position[1]
          elif base_plane == 'yz':

            hole_centre_coord_data[i][0]=hole_centre_coord_data[i][0]-machine_home_position[1]
            hole_centre_coord_data[i][1]=hole_centre_coord_data[i][1]-machine_home_position[2]
          else:

            hole_centre_coord_data[i][0]=hole_centre_coord_data[i][0]-machine_home_position[0]
            hole_centre_coord_data[i][1]=hole_centre_coord_data[i][1]-machine_home_position[2]
         # hole_centre_coord_data[i][2]=hole_centre_coord_data[i][2]-machine_home_position[2]
      return hole_centre_coord_data,thickness

def compute_euclidean_distance_matrix(locations):
    """Creates callback to return distance between points."""
    distances = {}
    for from_counter, from_node in enumerate(locations):
        distances[from_counter] = {}
        for to_counter, to_node in enumerate(locations):
            if from_counter == to_counter:
                distances[from_counter][to_counter] = 0
            else:
                # Euclidean distance
                distances[from_counter][to_counter] = (int(
                    math.hypot((from_node[0] - to_node[0]),
                               (from_node[1] - to_node[1]))))
    return distances

def print_solution(manager, routing, solution,data,thickness,spindle_speed=1000,feed_rate=50):
    """Prints solution on console."""
    print('Objective: {}'.format(solution.ObjectiveValue()))
    index = routing.Start(0)
    plan_output = 'Route:\n'
    route_distance = 0
    ##These two lines are added for part zero inserted in main code manually
    previous_index = index
    index = solution.Value(routing.NextVar(index))
    CNC_code='N10 G21 G90 G40 G80 G49 G54 G94 F50\n'
    CNC_code+='N20 M06 T1 \n'
    CNC_code+='N30 M03 S'+str(spindle_speed)+'\n'
    CNC_code+='N40 G00 X0 Y0 Z'+str(10+thickness/1000)+'\n'
    CNC_code+='N50 G99 G81 X'+str(data[manager.IndexToNode(index)][0]/1000)+' Y'+str(data[manager.IndexToNode(index)][1]/1000)+' F'+str(feed_rate)+' Z0 R'+str(5+thickness/1000)+'\n'
    previous_index = index
    index = solution.Value(routing.NextVar(index))
    route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)
    n=50
    while not routing.IsEnd(index):
        #print(data[manager.IndexToNode(index)])
        #plan_output += ' {} ->'.format(manager.IndexToNode(index))
        n+=10
        CNC_code+='N'+str(n)+' X'+str(data[manager.IndexToNode(index)][0]/1000)+' Y'+str(data[manager.IndexToNode(index)][1]/1000)+'\n'
        previous_index = index
        index = solution.Value(routing.NextVar(index))
        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)
    #plan_output += ' {}\n'.format(manager.IndexToNode(index))
    #check the above line execution if required since i am sending it to home position.
    n+=10
    CNC_code+='N'+str(n)+' G00 X0 Y0 Z'+str(10+thickness/1000)+'\n'
    n+=10
    CNC_code+='N'+str(n)+' M30\n'
   
    file1 = open("DataBase\\Exhaustive_Optimal_Tool_Path_Search\\CNC_code.txt","w")  
    file1.write(CNC_code) 
    file1.close()
    print(CNC_code)
    #plan_output += 'Objective: {}m\n'.format(route_distance)

filename = '/content/diamond_pattern.stp'

def main():
    """Entry point of the program."""
    # Instantiate the data problem.
    data,thickness = hole_data_details(filename)
    data.insert(0,[0,0])
    

    # Create the routing index manager.
    manager = pywrapcp.RoutingIndexManager(len(data),
                                           1, 0) #machine = 1, depot = 0

    # Create Routing Model.
    routing = pywrapcp.RoutingModel(manager)

    distance_matrix = compute_euclidean_distance_matrix(data)

    def distance_callback(from_index, to_index):
        """Returns the distance between the two nodes."""
        # Convert from routing variable Index to distance matrix NodeIndex.
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return distance_matrix[from_node][to_node]

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)

    # Define cost of each arc.
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    # ## Setting first solution heuristic.
    # search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    # search_parameters.first_solution_strategy = (
    #     routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)
##### For guided Local search enable this and disable above
    # Setting first solution heuristic.
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.local_search_metaheuristic = (
        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH)
    search_parameters.time_limit.seconds = 30 ##set time limit more for better search
    search_parameters.log_search = True

    # Solve the problem.
    solution = routing.SolveWithParameters(search_parameters)

    # Print solution on console.
    if solution:
        print_solution(manager, routing, solution,data,thickness)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# if __name__ == '__main__':
#     main()